import React, { useState, useCallback, useRef, useEffect } from "react";
import { Link, useSearch } from "wouter";
import Navigation from "@/components/navigation";
import EditorStage from "@/components/designer/EditorStage";
import { PropertiesPanel } from "@/components/designer/PropertiesPanel";
import { TemplateGallery } from "@/components/designer/TemplateGallery";
import { AIEnhancedToolsPanel } from "@/components/designer/AIEnhancedToolsPanel";
import { FloatingToolbar } from "@/components/designer/FloatingToolbar";
import { ProductSelector } from "@/components/designer/ProductSelector";
import { PrintProduct } from "@/lib/print-product-config";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/lib/auth";
import { useCart } from "@/hooks/use-cart";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Template } from "@/lib/template-schema";
import { templateService } from "@/lib/template-service";
import {
  Download,
  FileText,
  Image as ImageIcon,
  Sparkles,
  Palette,
  Menu,
  X,
  Plus,
  Save,
  Share2,
  Target,
  Grid3X3,
  CheckCircle,
  Lightbulb,
  Square,
  Circle,
  Triangle,
  Type,
  Image,
  Trash2,
  Copy,
  Undo,
  Redo,
  ShoppingCart,
  Settings,
  Layers,
  Eye,
  EyeOff,
  Upload,
  Palette as PaletteIcon,
  Wand2,
  Brain,
  Zap,
  Star,
  Heart,
  Clock,
  Users,
  TrendingUp,
  ChevronDown,
  ChevronRight,
  RotateCw,
  FlipHorizontal,
  FlipVertical,
  AlignLeft,
  AlignCenter,
  AlignRight,
  AlignJustify,
  Bold,
  Italic,
  Underline,
  Strikethrough,
  Minus,
  MoreHorizontal,
} from "lucide-react";

// Draggable Sidebar Component
const DraggableSidebar: React.FC<{
  title: string;
  onClose: () => void;
  defaultPosition: { x: number; y: number };
  children: React.ReactNode;
}> = ({ title, onClose, defaultPosition, children }) => {
  const [position, setPosition] = useState(defaultPosition);
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const sidebarRef = useRef<HTMLDivElement>(null);

  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget || (e.target as HTMLElement).closest('.drag-handle')) {
      setIsDragging(true);
      setDragStart({
        x: e.clientX - position.x,
        y: e.clientY - position.y
      });
      e.preventDefault();
    }
  }, [position]);

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (isDragging) {
      const newX = e.clientX - dragStart.x;
      const newY = e.clientY - dragStart.y;

      // Constrain to viewport
      const maxX = window.innerWidth - 340; // Sidebar width
      const maxY = window.innerHeight - 200; // Minimum height

      setPosition({
        x: Math.max(0, Math.min(newX, maxX)),
        y: Math.max(0, Math.min(newY, maxY))
      });
    }
  }, [isDragging, dragStart]);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  // Add/remove event listeners
  useEffect(() => {
    if (isDragging) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      document.body.style.cursor = 'grabbing';
      document.body.style.userSelect = 'none';
    } else {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    }

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    };
  }, [isDragging, handleMouseMove, handleMouseUp]);

  return (
    <div
      ref={sidebarRef}
      className={`fixed z-40 bg-white border border-gray-300 rounded-lg shadow-xl overflow-hidden ${
        isDragging ? 'shadow-2xl' : ''
      }`}
      style={{
        left: position.x,
        top: position.y,
        width: '320px',
        maxHeight: '80vh',
        cursor: isDragging ? 'grabbing' : 'default'
      }}
    >
      {/* Drag Handle */}
      <div
        className="drag-handle bg-gray-50 border-b border-gray-200 p-3 flex items-center justify-between flex-shrink-0 cursor-grab active:cursor-grabbing select-none"
        onMouseDown={handleMouseDown}
      >
        <div className="flex items-center space-x-2">
          <Menu className="w-4 h-4 text-gray-600" />
          <span className="text-sm font-medium text-gray-700">{title}</span>
        </div>
        <Button
          variant="ghost"
          size="sm"
          onClick={onClose}
          className="h-6 w-6 p-0 hover:bg-gray-200"
          title="Close Sidebar"
        >
          <X className="w-3 h-3" />
        </Button>
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto">
        {children}
      </div>
    </div>
  );
};

export default function KonvaDemo() {
  const MOCK_TEMPLATES = [
    {
      id: "template-1",
    name: "Modern Business Card",
    category: "business-cards",
    background: "#ffffff",
    accentColor: "#3b82f6",
    thumbnail:
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmZmIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMCIgZmlsbD0iIzNiODJmNiIvPjx0ZXh0IHg9IjEwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjMDAwIj5Nb2Rlcm4gQnVzaW5lc3M8L3RleHQ+PHRleHQgeD0iMTAiIHk9IjUwIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9IiM2NjYiPkNhcmQgRGVzaWduPC90ZXh0Pjwvc3ZnPg==",
    rating: 4.8,
    downloads: 1250,
    tags: ["modern", "professional", "clean"],
    elements: [
      { type: "rect", x: 0, y: 0, width: 90, height: 10, fill: "#3b82f6" },
      {
        type: "text",
        x: 10,
        y: 25,
        text: "JOHN DOE",
        fontSize: 16,
        fontFamily: "Arial",
        fill: "#000000",
      },
      {
        type: "text",
        x: 10,
        y: 40,
        text: "CEO & Founder",
        fontSize: 12,
        fontFamily: "Arial",
        fill: "#666666",
      },
      {
        type: "text",
        x: 10,
        y: 50,
        text: "john@company.com",
        fontSize: 10,
        fontFamily: "Arial",
        fill: "#666666",
      },
    ],
  },
  {
    id: "template-2",
    name: "Vintage Postcard",
    category: "postcards",
    background: "#fef3c7",
    accentColor: "#8b5a3a",
    thumbnail:
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmVmM2M3Ii8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMCIgZmlsbD0iIzhiNWEzYSIvPjx0ZXh0IHg9IjEwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjOGI1YTNhIj5WaW50YWdlPC90ZXh0Pjx0ZXh0IHg9IjEwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOGI1YTNhIj5Qb3N0Y2FyZDwvdGV4dD48L3N2Zz4=",
    rating: 4.7,
    downloads: 980,
    tags: ["vintage", "retro", "nostalgic"],
    elements: [
      { type: "rect", x: 0, y: 0, width: 148, height: 15, fill: "#8b5a3a" },
      {
        type: "text",
        x: 20,
        y: 40,
        text: "Greetings from",
        fontSize: 18,
        fontFamily: "Georgia",
        fill: "#8b5a3a",
      },
      {
        type: "text",
        x: 20,
        y: 70,
        text: "Beautiful Destination",
        fontSize: 24,
        fontFamily: "Georgia",
        fill: "#8b5a3a",
      },
    ],
  },
  {
    id: "template-3",
    name: "Creative Flyer",
    category: "flyers",
    background: "#fef2f2",
    accentColor: "#ef4444",
    thumbnail:
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZmVmMmYyIi8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMCIgZmlsbD0iI2VmNDQ0NCIvPjx0ZXh0IHg9IjEwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZWY0NDQ0Ij5DcmVhdGl2ZTwvdGV4dD48dGV4dCB4PSIxMCIgeT0iNTAiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxMiIgZmlsbD0iI2VmNDQ0NCI+Rmx5ZXIgRGVzaWduPC90ZXh0Pjwvc3ZnPg==",
    rating: 4.6,
    downloads: 890,
    tags: ["creative", "colorful", "eye-catching"],
    elements: [
      { type: "rect", x: 0, y: 0, width: 148, height: 20, fill: "#ef4444" },
      {
        type: "text",
        x: 30,
        y: 60,
        text: "SPECIAL EVENT",
        fontSize: 28,
        fontFamily: "Arial",
        fill: "#ef4444",
      },
      {
        type: "text",
        x: 30,
        y: 100,
        text: "Join us for an amazing experience",
        fontSize: 16,
        fontFamily: "Arial",
        fill: "#374151",
      },
      {
        type: "text",
        x: 30,
        y: 140,
        text: "Date: December 15, 2024",
        fontSize: 14,
        fontFamily: "Arial",
        fill: "#6b7280",
      },
    ],
  },
  {
    id: "template-4",
    name: "Elegant Poster",
    category: "posters",
    background: "#1f2937",
    accentColor: "#fbbf24",
    thumbnail:
      "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjEyMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWYyOTM3Ii8+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMCIgZmlsbD0iI2ZiYmYyNCIvPjx0ZXh0IHg9IjEwIiB5PSIzMCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjE0IiBmaWxsPSIjZmJmYjI0Ij5FbGVnYW50PC90ZXh0Pjx0ZXh0IHg9IjEwIiB5PSI1MCIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjZmJmYjI0Ij5Qb3N0ZXIgRGVzaWduPC90ZXh0Pjwvc3ZnPg==",
    rating: 4.9,
    downloads: 2100,
    tags: ["elegant", "minimal", "sophisticated"],
    elements: [
      { type: "rect", x: 0, y: 0, width: 297, height: 30, fill: "#fbbf24" },
      {
        type: "text",
        x: 50,
        y: 100,
        text: "EXHIBITION",
        fontSize: 48,
        fontFamily: "Georgia",
        fill: "#fbbf24",
      },
      {
        type: "text",
        x: 50,
        y: 200,
        text: "Contemporary Art Gallery",
        fontSize: 24,
        fontFamily: "Georgia",
        fill: "#ffffff",
      },
      {
        type: "text",
        x: 50,
        y: 300,
        text: "Opening Night: January 20, 2025",
        fontSize: 18,
        fontFamily: "Georgia",
        fill: "#d1d5db",
      },
    ],
  },
];

// Mock AI suggestions
const MOCK_AI_SUGGESTIONS = [
  {
    id: "ai-1",
    type: "color-palette",
    title: "Modern Color Palette",
    description: "Professional blues and grays",
    colors: ["#1e40af", "#3b82f6", "#64748b", "#94a3b8", "#e2e8f0"],
  },
  {
    id: "ai-2",
    type: "layout",
    title: "Grid Layout",
    description: "Clean 3-column grid system",
    preview: "grid-layout-preview",
  },
  {
    id: "ai-3",
    type: "typography",
    title: "Typography Pairing",
    description: "Inter + Playfair Display",
    fonts: ["Inter", "Playfair Display"],
  },
];

// Mock product data - maps to database product slugs
const MOCK_PRODUCTS = [
  {
    id: "business-card",
    nameEn: "Business Card",
    category: "business-cards",
    dimensions: { width: 90, height: 54 },
    description: "Standard business card size",
    priceRange: "฿50-200",
    useCases: ["Corporate branding", "Personal networking"],
    basePrice: 100,
    databaseSlug: "standard-business-card", // Maps to actual database product
  },
  {
    id: "postcard",
    nameEn: "Postcard",
    category: "postcards",
    dimensions: { width: 148, height: 105 },
    description: "Standard postcard size",
    priceRange: "฿100-300",
    useCases: ["Marketing campaigns", "Event invitations"],
    basePrice: 150,
    databaseSlug: "a4-flyer", // Maps to actual database product
  },
  {
    id: "flyer-a5",
    nameEn: "A5 Flyer",
    category: "flyers",
    dimensions: { width: 148, height: 210 },
    description: "Compact A5 size for flyers",
    priceRange: "฿150-500",
    useCases: ["Event promotion", "Product catalogs"],
    basePrice: 200,
    databaseSlug: "a4-flyer", // Maps to actual database product
  },
  {
    id: "flyer-a4",
    nameEn: "A4 Flyer",
    category: "flyers",
    dimensions: { width: 210, height: 297 },
    description: "Standard A4 size for detailed information",
    priceRange: "฿200-800",
    useCases: ["Event promotion", "Product catalogs"],
    basePrice: 300,
    databaseSlug: "a4-flyer", // Maps to actual database product
  },
  {
    id: "poster-a3",
    nameEn: "A3 Poster",
    category: "posters",
    dimensions: { width: 297, height: 420 },
    description: "Large format for impactful displays",
    priceRange: "฿500-1500",
    useCases: ["Event advertising", "Brand promotion"],
    basePrice: 800,
    databaseSlug: "vinyl-banner", // Maps to actual database product
  },
];

export default function KonvaDemo() {
  const { toast } = useToast();
  const { userId } = useAuth();
  const { cartCount } = useCart();
  const searchParams = useSearch();

  // Debug logging
  useEffect(() => {
    console.log('KonvaDemo mounted, showSidebar:', showSidebar);
    console.log('Screen width:', window.innerWidth);

    // Check editor ref after a delay
    setTimeout(() => {
      console.log('Editor ref after mount:', editorRef.current);
      if (editorRef.current) {
        console.log('Available methods:', Object.keys(editorRef.current));
      }
    }, 2000);
  }, []);

  // Core state
  const [selectedProduct, setSelectedProduct] = useState<PrintProduct | null>(null);
  const [selectedElements, setSelectedElements] = useState<any[]>([]);
  const [showSidebar, setShowSidebar] = useState(true);
  const [selectedTool, setSelectedTool] = useState("select");
  const [zoom, setZoom] = useState(1);
  const [showGuides, setShowGuides] = useState(true);
  const [showGrid, setShowGrid] = useState(false);
  const [editorState, setEditorState] = useState<any>(null);
  const [showTemplateGallery, setShowTemplateGallery] = useState(false);
  const [showAITools, setShowAITools] = useState(false);
  const [designName, setDesignName] = useState("Untitled Design");
  const [showCartDialog, setShowCartDialog] = useState(false);
  const [showPropertiesPanel, setShowPropertiesPanel] = useState(false);
  const [cartQuantity, setCartQuantity] = useState(1);
  const [canUndo, setCanUndo] = useState(false);
  const [canRedo, setCanRedo] = useState(false);
  const [cartOptions, setCartOptions] = useState<any>({});
  const [selectedColors, setSelectedColors] = useState<string[]>([]);
  const [currentTemplate, setCurrentTemplate] = useState<Template | null>(null);
  const [showAIPanel, setShowAIPanel] = useState(false);
  const [showPropertiesPanel, setShowPropertiesPanel] = useState(true);
  const [canvasDimensions, setCanvasDimensions] = useState({
    width: 840, // A4 width in pixels (210mm at 4px/mm)
    height: 1188, // A4 height in pixels (297mm at 4px/mm)
  });

  // Load template from URL parameters
  useEffect(() => {
    const searchParams = new URLSearchParams(window.location.search);
    const templateId = searchParams.get('template');
    const productId = searchParams.get('product');
    
    const loadTemplate = async () => {
      try {
        const template = await templateService.getTemplateByParams(templateId || undefined, productId || undefined);
        if (template) {
          setCurrentTemplate(template);
          if (editorRef.current?.loadTemplate) {
            editorRef.current.loadTemplate(template);
          }
        }
      } catch (error) {
        console.error('Failed to load template:', error);
      }
    };

    loadTemplate();
  }, []);

  const editorRef = useRef<any>(null);

  // Template selection handler
  const handleTemplateSelect = useCallback((template: Template) => {
    setCurrentTemplate(template);
    if (editorRef.current?.loadTemplate) {
      editorRef.current.loadTemplate(template);
    }
    setShowTemplateGallery(false);
    toast({
      title: "Template loaded",
      description: `Loaded "${template.metadata.title}" template`
    });
  }, [toast]);

  // Parse URL parameters for template loading
  const urlParams = new URLSearchParams(searchParams);
  const templateId = urlParams.get("template");
  const productId = urlParams.get("product");

  // Fetch template data if templateId is present
  const { data: templateData } = useQuery({
    queryKey: ["template", templateId],
    queryFn: async () => {
      if (!templateId) return null;
      const response = await fetch(`/api/templates/${templateId}`);
      if (!response.ok) throw new Error("Failed to fetch template");
      return response.json();
    },
    enabled: !!templateId,
  });

  // Fetch product data if productId is present
  const { data: productData } = useQuery({
    queryKey: ["product", productId],
    queryFn: async () => {
      if (!productId) return null;
      const response = await fetch(`/api/products/${productId}`);
      if (!response.ok) throw new Error("Failed to fetch product");
      return response.json();
    },
    enabled: !!productId,
  });



  

  // Parse size string from specifications
  const parseSizeFromSpecifications = useCallback((specifications: any) => {
    if (!specifications?.size) return { width: 400, height: 300 };

    const sizeStr = specifications.size;

    // Handle different size formats
    if (sizeStr.includes("A4")) {
      return { width: 210, height: 297 }; // A4 in mm
    } else if (sizeStr.includes("A5")) {
      return { width: 148, height: 210 }; // A5 in mm
    } else if (sizeStr.includes("A3")) {
      return { width: 297, height: 420 }; // A3 in mm
    } else if (sizeStr.includes("×") || sizeStr.includes("x")) {
      // Parse formats like "8.5cm x 8.5cm" or "9cm x 5.4cm"
      const match = sizeStr.match(
        /(\d+(?:\.\d+)?).*?(?:×|x).*?(\d+(?:\.\d+)?)/i
      );
      if (match) {
        const width = parseFloat(match[1]) * 10; // Convert cm to mm
        const height = parseFloat(match[2]) * 10; // Convert cm to mm
        return { width: Math.round(width), height: Math.round(height) };
      }
    } else if (sizeStr.includes("diameter") || sizeStr.includes("circle")) {
      // Handle circular items like stickers
      const match = sizeStr.match(/(\d+(?:\.\d+)?)/);
      if (match) {
        const diameter = parseFloat(match[1]) * 10; // Convert cm to mm
        return { width: Math.round(diameter), height: Math.round(diameter) };
      }
    }

    return { width: 400, height: 300 }; // Default fallback
  }, []);

  // Handle product loading from URL parameters
  useEffect(() => {
    if (productData && !selectedProduct) {
      setSelectedProduct(productData);

      // Determine canvas dimensions with proper fallbacks
      let dimensions = { width: 400, height: 300 };

      if (productData.dimensions?.width && productData.dimensions?.height) {
        // Use dimensions if available
        dimensions = {
          width: productData.dimensions.width,
          height: productData.dimensions.height,
        };
      } else if (productData.specifications) {
        // Parse size from specifications
        dimensions = parseSizeFromSpecifications(productData.specifications);
      }

      setCanvasDimensions(dimensions);

      toast({
        title: "Product Loaded",
        description: `Loaded ${productData.nameEn} (${dimensions.width}×${dimensions.height}mm)`,
      });
    }
  }, [productData, selectedProduct, parseSizeFromSpecifications, toast]);

  // Function to find matching mock template
  const findMatchingMockTemplate = useCallback(
    async (templateName: string, categoryId: string) => {
      console.log(
        "🎨 Finding mock template for:",
        templateName,
        "category:",
        categoryId
      );

      // Map database category IDs to mock template categories
      const categoryIdToMockCategory: { [key: string]: string } = {
        cmf1ahbz00005uc2shy136py5: "business-cards", // Business Cards
        cmf1ahbz90006uc2sqdm6o86y: "flyers", // Flyers & Brochures
        cmf1ahbzc0007uc2s8b4rwzib: "posters", // Banners & Posters
        cmf1ahbze0008uc2sihufp8ob: "stickers", // Stickers & Labels
      };

      // Try to load template from service
      let finalTemplate = null;
      try {
        if (templateId) {
          finalTemplate = await templateService.getTemplate(templateId);
        } else if (productId) {
          const mockCategory = categoryIdToMockCategory[productId] || "business-cards";
          const result = await templateService.fetchTemplates({ category: mockCategory });
          finalTemplate = result.templates.find(t => t.metadata.category === mockCategory) || result.templates[0];
        }
        
        if (!finalTemplate) {
          const result = await templateService.fetchTemplates();
          finalTemplate = result.templates[0];
        }
        
        console.log("🎨 Template loaded:", finalTemplate?.metadata?.title || "none");
      } catch (error) {
        console.error("🎨 Error loading template:", error);
        // Fallback to first available template
        const result = await templateService.fetchTemplates();
        finalTemplate = result.templates[0];
      }

      return finalTemplate;
    },
    []
  );

  // Function to load template from API data
  const loadTemplateFromAPI = useCallback(
    async (template: any) => {
      console.log("🎨 Starting template load for:", template.name, template);

      if (!editorRef.current) {
        toast({
          title: "Error",
          description: "Editor not ready yet",
          variant: "destructive",
        });
        return;
      }

      try {
        // Clear existing canvas first
        console.log("🎨 Clearing canvas");
        editorRef.current.clearCanvas();

        // Wait for canvas to clear and ensure proper canvas dimensions
        setTimeout(async () => {
          if (!editorRef.current) return;

          // Ensure canvas dimensions are properly set for the template
          const mockTemplate = await findMatchingMockTemplate(
            template.name,
            template.category
          );
          if (
            mockTemplate &&
            mockTemplate.layers &&
            Array.isArray(mockTemplate.layers)
          ) {
            try {
              // Calculate appropriate canvas size based on template layers
              const maxX = Math.max(
                ...mockTemplate.layers.map(
                  (el) => (el.x || 0) + (el.width || 100)
                )
              );
              const maxY = Math.max(
                ...mockTemplate.layers.map(
                  (el) => (el.y || 0) + (el.height || 50)
                )
              );
              const canvasWidth = Math.max(maxX + 50, 400); // Minimum 400px
              const canvasHeight = Math.max(maxY + 50, 300); // Minimum 300px

              console.log(
                "🎨 Setting canvas size for template:",
                canvasWidth,
                "x",
                canvasHeight
              );
              setCanvasDimensions({ width: canvasWidth, height: canvasHeight });
            } catch (calcError) {
              console.warn("Error calculating canvas dimensions:", calcError);
              // Use default dimensions
              setCanvasDimensions({ width: 400, height: 300 });
            }
          } else {
            console.log("🎨 Using default canvas size");
            setCanvasDimensions({ width: 400, height: 300 });
          }

          // Wait for canvas dimensions to update before loading elements
          setTimeout(async () => {
            if (!editorRef.current) return;

            // Ensure canvas dimensions are reasonable
            if (canvasDimensions.width < 100 || canvasDimensions.height < 100) {
              console.warn("🎨 Canvas dimensions too small, using defaults");
              setCanvasDimensions({ width: 400, height: 300 });
              return;
            }

            console.log(
              "🎨 Starting template element loading with canvas size:",
              canvasDimensions.width,
              "x",
              canvasDimensions.height
            );

            // Priority 1: Use templateData if available (Konva JSON)
            if (template.templateData) {
              console.log(
                "🎨 Loading template with templateData:",
                template.templateData
              );
              try {
                editorRef.current.loadState(template.templateData);
                toast({
                  title: "Template Loaded",
                  description: `Loaded ${template.name} template`,
                });
              } catch (error) {
                console.error("Error loading templateData:", error);
                toast({
                  title: "Template Load Error",
                  description:
                    "Failed to load template data. Please try again.",
                  variant: "destructive",
                });
              }
              return;
            }

            // Priority 2: Use layers array if available (legacy format)
            if (template.layers && Array.isArray(template.layers)) {
              console.log(
                "🎨 Loading template with layers:",
                template.layers
              );
              template.layers.forEach((element: any, index: number) => {
                setTimeout(() => {
                  try {
                    console.log("🎨 Loading element:", index, element);
                    if (element.type === "text") {
                      const textNode = editorRef.current?.addText?.(
                        element.x || 50,
                        element.y || 50
                      );
                      if (textNode) {
                        if (element.text) textNode.text(element.text);
                        if (element.fontSize)
                          textNode.fontSize(element.fontSize);
                        if (element.fontFamily)
                          textNode.fontFamily(element.fontFamily);
                        if (element.fill) textNode.fill(element.fill);
                        console.log(
                          "🎨 Legacy text element loaded:",
                          element.text
                        );
                      }
                    } else if (
                      element.type === "rect" ||
                      element.type === "rectangle"
                    ) {
                      console.log(
                        "🎨 Adding rectangle at:",
                        element.x || 50,
                        element.y || 50
                      );
                      const rectNode = editorRef.current?.addShape?.(
                        "rectangle",
                        element.x || 50,
                        element.y || 50
                      );
                      if (rectNode && element.fill) {
                        rectNode.fill(element.fill);
                      }
                      console.log("🎨 Legacy rectangle loaded");
                    }
                  } catch (elementError) {
                    console.warn(
                      "Error loading element:",
                      element,
                      elementError
                    );
                  }
                }, index * 200);
              });

              toast({
                title: "Template Applied",
                description: `Applied ${template.name} template`,
              });
              return;
            }

            // Priority 3: Use mock template as fallback
            console.log(
              "🎨 Using mock template fallback for:",
              template.name,
              "category:",
              template.category
            );
            const mockTemplate = await findMatchingMockTemplate(
              template.name,
              template.category
            );

            if (mockTemplate.layers && Array.isArray(mockTemplate.layers)) {
              console.log(
                "🎨 Loading mock template layers:",
                mockTemplate.layers.length,
                "layers"
              );

              // Load layers sequentially with proper error handling
              mockTemplate.layers.forEach((element: any, index: number) => {
                setTimeout(() => {
                  try {
                    console.log("🎨 Loading mock element:", index, element);

                    if (element.type === "text") {
                      console.log(
                        "🎨 Creating text element:",
                        element.text,
                        "at",
                        element.x,
                        element.y
                      );

                      // Ensure coordinates are within canvas bounds
                      const canvasWidth = canvasDimensions.width;
                      const canvasHeight = canvasDimensions.height;
                      const safeX = Math.max(
                        10,
                        Math.min(element.x || 50, canvasWidth - 100)
                      );
                      const safeY = Math.max(
                        10,
                        Math.min(element.y || 50, canvasHeight - 50)
                      );

                      console.log(
                        "🎨 Safe coordinates:",
                        safeX,
                        safeY,
                        "Canvas size:",
                        canvasWidth,
                        canvasHeight
                      );

                      // Create text node with all properties at once
                      const textNode = editorRef.current?.addText?.(
                        safeX,
                        safeY
                      );
                      if (textNode) {
                        // Set text properties safely with additional error checking and delay
                        setTimeout(() => {
                          try {
                            if (
                              element.text &&
                              typeof element.text === "string"
                            ) {
                              textNode.text(element.text);
                            }
                            if (
                              element.fontSize &&
                              typeof element.fontSize === "number"
                            ) {
                              textNode.fontSize(element.fontSize);
                            }
                            if (
                              element.fontFamily &&
                              typeof element.fontFamily === "string"
                            ) {
                              textNode.fontFamily(element.fontFamily);
                            }
                            if (
                              element.fill &&
                              typeof element.fill === "string"
                            ) {
                              textNode.fill(element.fill);
                            }
                            if (
                              element.width &&
                              typeof element.width === "number"
                            ) {
                              textNode.width(element.width);
                            }
                            if (
                              element.align &&
                              typeof element.align === "string"
                            ) {
                              textNode.align(element.align);
                            }
                            if (
                              element.rotation !== undefined &&
                              typeof element.rotation === "number"
                            ) {
                              textNode.rotation(element.rotation);
                            }
                            console.log(
                              "🎨 Text element created and configured:",
                              textNode.text()
                            );
                          } catch (propError) {
                            console.warn(
                              "Could not set text property:",
                              propError,
                              "Element:",
                              element
                            );
                          }
                        }, 50); // Small delay to ensure element is ready
                      } else {
                        console.error("🎨 Failed to create text node");
                      }
                    } else if (
                      element.type === "rect" ||
                      element.type === "rectangle"
                    ) {
                      console.log(
                        "🎨 Creating rectangle at:",
                        element.x || 50,
                        element.y || 50,
                        "size:",
                        element.width || 100,
                        element.height || 50
                      );

                      // Ensure coordinates are within canvas bounds
                      const canvasWidth = canvasDimensions.width;
                      const canvasHeight = canvasDimensions.height;
                      const safeX = Math.max(
                        0,
                        Math.min(
                          element.x || 50,
                          canvasWidth - (element.width || 100)
                        )
                      );
                      const safeY = Math.max(
                        0,
                        Math.min(
                          element.y || 50,
                          canvasHeight - (element.height || 50)
                        )
                      );

                      console.log(
                        "🎨 Safe rectangle coordinates:",
                        safeX,
                        safeY
                      );

                      // Create rectangle using EditorStage method
                      const rectNode = editorRef.current?.addShape?.(
                        "rectangle",
                        safeX,
                        safeY
                      );
                      if (rectNode) {
                                              // Set rectangle properties safely with type checking and delay
                      setTimeout(() => {
                        try {
                          if (
                            element.width &&
                            typeof element.width === "number"
                          ) {
                            rectNode.width(element.width);
                          }
                          if (
                            element.height &&
                            typeof element.height === "number"
                          ) {
                            rectNode.height(element.height);
                          }
                          if (
                            element.fill &&
                            typeof element.fill === "string"
                          ) {
                            rectNode.fill(element.fill);
                          }
                          if (
                            element.stroke &&
                            typeof element.stroke === "string"
                          ) {
                            rectNode.stroke(element.stroke);
                          }
                          if (
                            element.strokeWidth !== undefined &&
                            typeof element.strokeWidth === "number"
                          ) {
                            rectNode.strokeWidth(element.strokeWidth);
                          }
                          if (
                            element.rotation !== undefined &&
                            typeof element.rotation === "number"
                          ) {
                            rectNode.rotation(element.rotation);
                          }
                          console.log(
                            "🎨 Rectangle created and configured:",
                            rectNode.width(),
                            rectNode.height()
                          );
                        } catch (propError) {
                          console.warn(
                            "Could not set rectangle property:",
                            propError,
                            "Element:",
                            element
                          );
                        }
                      }, 50); // Small delay to ensure element is ready
                      } else {
                        console.error("🎨 Failed to create rectangle");
                      }
                    }
                  } catch (elementError) {
                    console.warn(
                      "Error loading mock element:",
                      element,
                      elementError
                    );
                  }
                }, index * 300); // Increased delay to prevent conflicts
              });

              // Force a redraw after all elements are loaded
              setTimeout(() => {
                if (editorRef.current) {
                  // Trigger a state update to force canvas redraw
                  editorRef.current.forceRefreshCanvasState?.();
                  console.log("🎨 Template loading complete, canvas refreshed");
                }
              }, mockTemplate.layers.length * 300 + 100);

              toast({
                title: "Template Applied",
                description: `Applied ${template.name} template (using template library)`,
              });
            } else {
              console.log(
                "🎨 No mock template elements found, using basic fallback"
              );
              // Final fallback - just add a simple text element
              setTimeout(() => {
                try {
                  const textNode = editorRef.current?.addText?.(50, 50);
                  if (textNode) {
                    textNode.text(`${template.name} Template`);
                    textNode.fontSize(24);
                    textNode.fill("#333333");
                    console.log("🎨 Basic fallback text created");
                  }
                } catch (fallbackError) {
                  console.warn("Error with final fallback:", fallbackError);
                }
              }, 100);

              toast({
                title: "Basic Template Created",
                description: `Created basic template for ${template.name}`,
              });
            }
          }, 200); // Close the setTimeout that waits for canvas dimensions
        }, 100); // Close the setTimeout that wraps the template loading
      } catch (error) {
        console.error("Error loading template:", error);
        toast({
          title: "Template Load Error",
          description: "Failed to load the template. Please try again.",
          variant: "destructive",
        });
      }
    },
    [toast, findMatchingMockTemplate, canvasDimensions]
  );

  // Handle template loading from URL parameters
  useEffect(() => {
    const loadTemplate = async () => {
      if (templateData && editorRef.current && !selectedProduct) {
        // Load the template into the canvas
        await loadTemplateFromAPI(templateData);
      }
    };
    loadTemplate();
  }, [templateData, selectedProduct, loadTemplateFromAPI]);

  // Product selection handler
  const handleProductSelect = useCallback(
    (product: PrintProduct) => {
      console.log('🎯 Product selected:', product);
      setSelectedProduct(product);

      // Determine canvas dimensions with proper fallbacks
      let dimensions = { width: 400, height: 300 };

      if (product.dimensions?.width && product.dimensions?.height) {
        // Use dimensions if available
        dimensions = {
          width: product.dimensions.width,
          height: product.dimensions.height,
        };
      }

      console.log('📐 Setting canvas dimensions to:', dimensions);
      setCanvasDimensions(dimensions);

      // Force canvas refresh if editor is ready
      if (editorRef.current) {
        console.log('🔄 Refreshing canvas with new dimensions');
        setTimeout(() => {
          if (editorRef.current?.forceRefreshCanvasState) {
            editorRef.current.forceRefreshCanvasState();
          }
        }, 100);
      }

      toast({
        title: "Product Selected",
        description: `Started designing for ${product.nameEn} (${dimensions.width}×${dimensions.height}mm)`,
      });
    },
    [parseSizeFromSpecifications, toast]
  );

  // Template selection handler already defined above

  // AI suggestion handler
  const handleAISuggestion = useCallback(
    (suggestion: any) => {
      toast({
        title: "AI Suggestion Applied",
        description: `Applied ${suggestion.title}`,
      });
    },
    [toast]
  );

  // State change handler
  const handleStateChange = useCallback((state: any) => {
    setEditorState(state);
  }, []);

  // Element selection handler
  const handleElementSelect = useCallback((element: any) => {
    console.log("🔍 handleElementSelect called with element:", element);
    console.log("🔍 Element type:", element?.type);
    console.log("🔍 Element id:", element?.id);
    setSelectedElements(element ? [element] : []);
  }, []);

  // Tool handlers
  const handleToolChange = useCallback(
    (tool: string) => {
      setSelectedTool(tool);
      toast({
        title: "Tool Changed",
        description: `Switched to ${tool} tool`,
      });
    },
    [toast]
  );

  const handleAddText = useCallback(() => {
    console.log("handleAddText called");
    console.log("editorRef.current:", editorRef.current);
    console.log("editorRef.current?.addText:", editorRef.current?.addText);

    if (!editorRef.current) {
      console.error("Editor ref is null");
      toast({
        title: "Error",
        description: "Editor not initialized yet",
        variant: "destructive",
      });
      return;
    }

    if (!editorRef.current.addText) {
      console.error("addText method not found on editor");
      toast({
        title: "Error",
        description: "Text tool not available",
        variant: "destructive",
      });
      return;
    }

    try {
      const result = editorRef.current.addText();
      console.log("addText result:", result);

      if (result) {
        toast({
          title: "Text Added",
          description: "Text element added to canvas center",
        });
      } else {
        console.warn("addText returned null/undefined");
        toast({
          title: "Warning",
          description: "Text may not have been added properly",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error("Error adding text:", error);
        toast({
          title: "Error",
        description: "Failed to add text element",
          variant: "destructive",
        });
      }
  }, [toast]);



  const handleAddImage = useCallback(() => {
    // Create a file input for image upload
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "image/*";
    fileInput.style.display = "none";

    fileInput.onchange = (event) => {
      const file = (event.target as HTMLInputElement).files?.[0];
      if (file && editorRef.current?.addImage) {
        const reader = new FileReader();
        reader.onload = (e) => {
          const imageUrl = e.target?.result as string;
          editorRef.current.addImage(imageUrl);
          toast({
            title: "Image Added",
            description: "Image uploaded and added to canvas",
          });
        };
        reader.readAsDataURL(file);
      }
      // Clean up
      document.body.removeChild(fileInput);
    };

    // Trigger file selection
    document.body.appendChild(fileInput);
    fileInput.click();
  }, [toast]);

  const handleImageUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (file && editorRef.current?.addImage) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const imageUrl = e.target?.result as string;
        editorRef.current?.addImage(imageUrl);
        toast({
          title: "Image Added",
          description: "Image uploaded and added to canvas",
        });
      };
      reader.readAsDataURL(file);
    }
    // Reset the input
    event.target.value = '';
  }, [toast]);

  const handleUndo = useCallback(() => {
    if (editorRef.current?.undo) {
      const success = editorRef.current.undo();
      if (success) {
        toast({
          title: "Undo",
          description: "Action undone",
        });
      } else {
        toast({
          title: "No Actions",
          description: "Nothing to undo",
          variant: "destructive",
        });
      }
    } else {
      toast({
        title: "Error",
        description: "Editor not ready yet",
        variant: "destructive",
      });
    }
  }, [toast]);

  const handleRedo = useCallback(() => {
    if (editorRef.current?.redo) {
      const success = editorRef.current.redo();
      if (success) {
        toast({
          title: "Redo",
          description: "Action redone",
        });
      } else {
        toast({
          title: "No Actions",
          description: "Nothing to redo",
          variant: "destructive",
        });
      }
    } else {
      toast({
        title: "Error",
        description: "Editor not ready yet",
        variant: "destructive",
      });
    }
  }, [toast]);

  const handleSave = useCallback(() => {
    if (editorRef.current?.saveDesign) {
      editorRef.current.saveDesign();
      toast({
        title: "Design Saved",
        description: "Your design has been saved",
      });
    } else {
      toast({
        title: "Error",
        description: "Editor not ready yet",
        variant: "destructive",
      });
    }
  }, [toast]);

  const handleExport = useCallback(() => {
    if (editorRef.current?.exportDesign) {
      editorRef.current.exportDesign();
      toast({
        title: "Export Successful",
        description: "Design exported successfully",
      });
    } else {
      toast({
        title: "Error",
        description: "Editor not ready yet",
        variant: "destructive",
      });
    }
  }, [toast]);

  const handleAddToCart = useCallback(() => {
    if (!selectedProduct) {
      toast({
        title: "No Product Selected",
        description: "Please select a product first",
        variant: "destructive",
      });
      return;
    }

    // Open cart dialog for quantity and options selection
    setShowCartDialog(true);
  }, [selectedProduct]);

  // Helper function to get the correct database product slug from mock product ID
  const getDatabaseProductSlug = useCallback((mockProductId: string): string => {
    const product = MOCK_PRODUCTS.find(p => p.id === mockProductId);
    return product?.databaseSlug || mockProductId;
  }, []);

  const handleConfirmAddToCart = useCallback(async () => {
    if (!selectedProduct || !userId) return;

    // Get current design state
    const designData = editorRef.current?.getState
      ? editorRef.current.getState()
      : null;

    // Validate that there's content in the design
    const hasTexts = designData.texts && designData.texts.length > 0;
    const hasImages = designData.images && designData.images.length > 0;
    const hasContent = hasTexts || hasImages;

    if (!designData || !hasContent) {
      toast({
        title: "Empty Design",
        description:
          "Please add some content (text or images) to your design before adding to cart",
        variant: "destructive",
      });
      return;
    }

    // Calculate total price based on quantity and options
    // Extract base price from price range (use the lower end)
    const priceMatch = selectedProduct.priceRange.match(/฿(\d+)-(\d+)/);
    const basePrice = priceMatch ? parseInt(priceMatch[1]) : 100; // Default to ฿100 if parsing fails
    let totalPrice = basePrice * cartQuantity;

    // Add option costs if any
    Object.values(cartOptions).forEach((option: any) => {
      if (option.value === 'premium') {
        totalPrice += 50 * cartQuantity; // Premium options add ฿50
      }
    });

    try {
      // Get the correct database product slug from the mock product ID
      const databaseProductSlug = getDatabaseProductSlug(selectedProduct.id);

      // Transform cartOptions object into array format expected by server
      const selectedOptionsArray = Object.entries(cartOptions).map(([type, option]: [string, any]) => ({
        id: `${type}-${option.value}`, // Create a unique ID
        productId: databaseProductSlug, // Use the database product slug
        type: type,
        nameEn: option.value,
        nameTh: option.value,
        defaultPriceModifier: option.value === 'premium' ? 50 : 0, // Add premium pricing
        priceRules: null,
        isDefault: false,
      }));

      // Add to cart using API directly
      await apiRequest("POST", "/api/cart", {
        userId,
        productId: databaseProductSlug, // Use the database product slug instead of mock ID
        designProjectId: null, // This would be set if we had design projects
        quantity: cartQuantity,
        selectedOptions: selectedOptionsArray, // Send as array
        unitPrice: basePrice.toString(),
        totalPrice: totalPrice.toString(),
      });

      // Invalidate cart queries to refresh the cart
      queryClient.invalidateQueries({ queryKey: ["/api/cart", userId] });

      toast({
        title: "Added to Cart",
        description: `${designName} (${cartQuantity} × ${selectedProduct.nameEn}) added to cart`,
      });

      setShowCartDialog(false);
      setCartQuantity(1);
      setCartOptions({});
    } catch (error: any) {
      toast({
        title: "Failed to add to cart",
        description: error?.message || "Please try again.",
        variant: "destructive",
      });
    }
  }, [selectedProduct, designName, cartQuantity, cartOptions, userId, toast, getDatabaseProductSlug]);

  const handleGoToCart = useCallback(() => {
    // Navigate to cart page with the items
    window.location.href = "/cart";
  }, []);

  // AI Design Generation Mutation
  const generateDesignMutation = useMutation({
    mutationFn: async (data: { prompt: string; productType: string; dimensions: { width: number; height: number } }) => {
      const response = await apiRequest("POST", "/api/ai/design-from-text", {
        prompt: data.prompt,
        productType: data.productType,
        dimensions: data.dimensions,
      });
      return response;
    },
    onSuccess: (designData: any) => {
      console.log("AI Design generated:", designData);
      toast({
        title: "AI Design Generated",
        description: "Design has been applied to canvas",
      });

      // Apply the generated design to the canvas
      if (editorRef.current?.loadState && designData) {
        try {
          // Convert AI design format to canvas format
          const canvasState = {
            version: "5.3.0",
            objects: designData.layers?.map((element: any, index: number) => ({
              type: element.type,
              version: "5.3.0",
              originX: "center",
              originY: "center",
              left: element.position?.x || 100,
              top: element.position?.y || 100,
              width: element.type === 'text' ? 200 : 100,
              height: element.type === 'text' ? 50 : 100,
              fill: element.style?.color || element.style?.fill || '#000000',
              stroke: null,
              strokeWidth: 0,
              strokeDashArray: null,
              strokeLineCap: "butt",
              strokeDashOffset: 0,
              strokeLineJoin: "miter",
              strokeUniform: false,
              strokeMiterLimit: 4,
              scaleX: 1,
              scaleY: 1,
              angle: 0,
              flipX: false,
              flipY: false,
              opacity: 1,
              shadow: null,
              visible: true,
              backgroundColor: "",
              fillRule: "nonzero",
              paintFirst: "fill",
              globalCompositeOperation: "source-over",
              skewX: 0,
              skewY: 0,
              rx: 0,
              ry: 0,
              ...(element.type === 'text' ? {
                text: element.content,
                fontSize: element.style?.fontSize || 28,
                fontFamily: element.style?.fontFamily || 'Arial',
                fontWeight: element.style?.fontWeight || 'normal',
                fontStyle: element.style?.fontStyle || 'normal',
                textAlign: element.style?.textAlign || 'left',
                lineHeight: 1.16,
                charSpacing: 0,
                textBackgroundColor: "",
                underline: false,
                overline: false,
                linethrough: false,
              } : {}),
              name: `ai-element-${index}`,
              selectable: true,
              evented: true,
              lockMovementX: false,
              lockMovementY: false,
              lockRotation: false,
              lockScalingX: false,
              lockScalingY: false,
              hasControls: true,
              hasBorders: true,
              hasRotatingPoint: true,
              rotatingPointOffset: 40,
              perPixelTargetFind: false,
              targetFindTolerance: 4,
              lockUniScaling: false,
            })) || []
          };

          editorRef.current.loadState(canvasState);
        } catch (error) {
          console.error("Error applying AI design:", error);
          toast({
            title: "Error",
            description: "Failed to apply generated design",
            variant: "destructive",
          });
        }
      }
    },
    onError: (error: any) => {
      console.error("AI Design generation failed:", error);
      toast({
        title: "AI Design Failed",
        description: error.message || "Failed to generate design from prompt",
        variant: "destructive",
      });
    },
  });

  // AI Color Palette Generation Mutation
  const generateColorPaletteMutation = useMutation({
    mutationFn: async (data: { brandDescription: string; industry: string }) => {
      const response = await apiRequest("POST", "/api/ai/color-palette", {
        brandDescription: data.brandDescription,
        industry: data.industry,
      });
      return response;
    },
    onSuccess: (paletteData: any) => {
      console.log("AI Color Palette generated:", paletteData);
      toast({
        title: "Color Palette Generated",
        description: "New color palette has been created",
      });

      // Update selected colors if available
      if (paletteData && typeof paletteData === 'object') {
        const colors = [];
        if (paletteData.primary) colors.push(paletteData.primary);
        if (paletteData.secondary) colors.push(paletteData.secondary);
        if (paletteData.accent) colors.push(paletteData.accent);
        if (paletteData.neutral && Array.isArray(paletteData.neutral)) {
          colors.push(...paletteData.neutral.slice(0, 2)); // Add first 2 neutrals
        }
        setSelectedColors(colors);
      }
    },
    onError: (error: any) => {
      console.error("AI Color Palette generation failed:", error);
      toast({
        title: "Color Palette Failed",
        description: error.message || "Failed to generate color palette",
        variant: "destructive",
      });
    },
  });

  const handleAIAssistant = useCallback(() => {
    setShowAITools(true);
    toast({
      title: "AI Assistant",
      description: "AI tools panel opened",
    });
  }, [toast]);

  const handleAddShape = useCallback((shapeType: "rectangle" | "circle" | "ellipse" | "triangle") => {
    console.log("Adding shape:", shapeType);
    if (!editorRef.current?.addShape) {
      console.error("addShape method not available on editor");
      toast({
        title: "Error",
        description: "Shape tool not available",
        variant: "destructive",
      });
      return;
    }

    try {
      const result = editorRef.current.addShape(shapeType);
      console.log("Shape added result:", result);

      if (result) {
        toast({
          title: "Shape Added",
          description: `${shapeType.charAt(0).toUpperCase() + shapeType.slice(1)} added to canvas`,
        });
      } else {
        console.warn("Shape may not have been added properly");
        toast({
          title: "Warning",
          description: "Shape may not have been added properly",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error("Error adding shape:", error);
      toast({
        title: "Error",
        description: `Failed to add ${shapeType}`,
        variant: "destructive",
      });
    }
  }, [editorRef, toast]);

  const handleGenerateColors = useCallback(() => {
    if (!selectedProduct) {
    toast({
        title: "No Product Selected",
        description: "Please select a product first",
        variant: "destructive",
      });
      return;
    }

    generateColorPaletteMutation.mutate({
      brandDescription: `Design for ${selectedProduct.nameEn}`,
      industry: selectedProduct.category || "general",
    });
  }, [selectedProduct, generateColorPaletteMutation, toast]);

  const handleZoomIn = useCallback(() => {
    if (editorRef.current?.zoomIn) {
      editorRef.current.zoomIn();
    }
    setZoom((prev) => Math.min(prev * 1.2, 3));
  }, []);

  const handleZoomOut = useCallback(() => {
    if (editorRef.current?.zoomOut) {
      editorRef.current.zoomOut();
    }
    setZoom((prev) => Math.max(prev / 1.2, 0.1));
  }, []);

  const handleResetZoom = useCallback(() => {
    if (editorRef.current?.resetView) {
      editorRef.current.resetView();
    }
    setZoom(1);
  }, []);

  const handleToggleGuides = useCallback(() => {
    setShowGuides((prev) => !prev);
  }, []);

  const handleToggleGrid = useCallback(() => {
    setShowGrid((prev) => !prev);
  }, []);

  // PropertiesPanel methods
  const handleDeleteSelected = useCallback(() => {
    console.log("🔵 handleDeleteSelected called");
    console.log("🔵 editorRef.current exists:", !!editorRef.current);
    console.log("🔵 deleteSelected method exists:", !!editorRef.current?.deleteSelected);

    if (editorRef.current?.deleteSelected) {
      console.log("🔵 Calling editorRef.current.deleteSelected()");
      editorRef.current.deleteSelected();
      setSelectedElements([]);
      toast({
        title: "Element Deleted",
        description: "Selected element removed from canvas",
      });
    } else {
      console.log("❌ deleteSelected method not available");
      toast({
        title: "Error",
        description: "Delete method not available",
        variant: "destructive",
      });
    }
  }, [toast]);

  const handleDownloadPreview = useCallback(() => {
    if (editorRef.current?.exportDesign) {
      editorRef.current.exportDesign();
      toast({
        title: "Preview Downloaded",
        description: "Design preview exported successfully",
      });
    }
  }, [toast]);

  const handleValidateForPrint = useCallback(() => {
    // Simple validation - check if there are elements on canvas
    const elementCount = editorRef.current?.getAllTexts
      ? editorRef.current.getAllTexts().length
      : 0;
    const errors = [];

    if (elementCount === 0) {
      errors.push("No elements on canvas");
    }

    if (!selectedProduct) {
      errors.push("No product selected");
    }

    return errors;
  }, [selectedProduct]);

  const handleExportForPrint = useCallback(() => {
    return {
      designName,
      product: selectedProduct,
      elements: editorRef.current?.getState
        ? editorRef.current.getState()
        : null,
      timestamp: new Date().toISOString(),
    };
  }, [designName, selectedProduct]);

  const handleResizeCanvas = useCallback((width: number, height: number) => {
    setCanvasDimensions({ width, height });
    // Note: Actual canvas resizing would need to be implemented in EditorStage
    return true;
  }, []);

  const handleForceRefreshCanvas = useCallback(() => {
    if (editorRef.current?.forceRefreshCanvasState) {
      editorRef.current.forceRefreshCanvasState();
    }
  }, []);

  const handleCreateTestObject = useCallback(() => {
    if (editorRef.current?.addText) {
      editorRef.current.addText();
    return true;
    }
    return false;
  }, []);

  // If user is not authenticated, show login prompt
  if (!userId) {
    return (
      <div className="h-screen bg-gray-50 flex flex-col">
        <Navigation />
        <div className="flex-1 flex items-center justify-center p-4">
          <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8 text-center">
            <div className="w-16 h-16 mx-auto bg-blue-100 rounded-full flex items-center justify-center mb-6">
              <Sparkles className="w-8 h-8 text-blue-600" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-4">
              AI Designer
            </h2>
            <p className="text-gray-600 mb-6">
              Create stunning designs with our AI-powered design studio. Please
              log in to access the designer and start creating.
            </p>
            <div className="space-y-4">
              <Link href="/login">
                <Button className="w-full bg-primary text-white hover:bg-primary-600">
                  Log In to Start Designing
                </Button>
              </Link>
              <p className="text-sm text-gray-500">
                Don't have an account?{" "}
                <Link href="/login" className="text-primary hover:underline">
                  Sign up here
                </Link>
              </p>
            </div>
            <div className="mt-8 pt-6 border-t border-gray-200">
              <div className="grid grid-cols-3 gap-4 text-center">
                <div>
                  <div className="w-8 h-8 mx-auto bg-green-100 rounded-full flex items-center justify-center mb-2">
                    <Sparkles className="w-4 h-4 text-green-600" />
                  </div>
                  <span className="text-xs text-gray-600">AI-Powered</span>
                </div>
                <div>
                  <div className="w-8 h-8 mx-auto bg-blue-100 rounded-full flex items-center justify-center mb-2">
                    <Brain className="w-4 h-4 text-blue-600" />
                  </div>
                  <span className="text-xs text-gray-600">Smart Templates</span>
                </div>
                <div>
                  <div className="w-8 h-8 mx-auto bg-purple-100 rounded-full flex items-center justify-center mb-2">
                    <Zap className="w-4 h-4 text-purple-600" />
                  </div>
                  <span className="text-xs text-gray-600">Instant Export</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen bg-gray-50 flex flex-col">
      <Navigation />
      
      {/* Floating Toolbar */}
      <FloatingToolbar
        selectedTool={selectedTool}
        setSelectedTool={setSelectedTool}
        zoom={zoom}
        setZoom={setZoom}
        showGuides={showGuides}
        setShowGuides={setShowGuides}
        showGrid={showGrid}
        setShowGrid={setShowGrid}
        canUndo={canUndo}
        canRedo={canRedo}
        onUndo={() => editorRef.current?.undo?.()}
        onRedo={() => editorRef.current?.redo?.()}
        onSave={handleSave}
        onExport={() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            const link = document.createElement('a');
            link.download = 'design.png';
            link.href = canvas.toDataURL();
            link.click();
          }
        }}
        onTemplateGalleryOpen={() => setShowTemplateGallery(true)}
        onAIPanelOpen={() => setShowAIPanel(true)}
        onAddToCart={handleAddToCart}
        onAddText={() => {
          if (editorRef.current?.addText) {
            const centerX = canvasDimensions.width / 2;
            const centerY = canvasDimensions.height / 2;
            editorRef.current.addText(centerX, centerY);
          }
        }}
        onAddShape={(shape) => {
          if (editorRef.current?.addShape) {
            const centerX = canvasDimensions.width / 2;
            const centerY = canvasDimensions.height / 2;
            editorRef.current.addShape(shape, centerX, centerY);
          }
        }}
        onAddImage={() => {
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = 'image/*';
          input.onchange = (e) => {
            const file = (e.target as HTMLInputElement).files?.[0];
            if (file && editorRef.current?.addImage) {
              const url = URL.createObjectURL(file);
              const centerX = canvasDimensions.width / 2;
              const centerY = canvasDimensions.height / 2;
              editorRef.current.addImage(url, centerX, centerY);
            }
          };
          input.click();
        }}
        editorRef={editorRef}
        canvasDimensions={canvasDimensions}
        showPropertiesPanel={showPropertiesPanel}
        onTogglePropertiesPanel={() => setShowPropertiesPanel(!showPropertiesPanel)}
      />

      {/* Desktop Layout */}
      <div className="flex-1 flex overflow-hidden">
        {/* Left Sidebar - Product Selection */}
        {showSidebar && (
          <DraggableSidebar
            title="Products"
            onClose={() => setShowSidebar(false)}
            defaultPosition={{ x: 20, y: 100 }}
          >
            <div className="p-4">
              <h2 className="text-lg font-semibold">Products</h2>
            </div>
            <Separator />
            <div className="p-4">
              <ProductSelector
                onProductSelect={handleProductSelect}
                currentProduct={selectedProduct || undefined}
              />
            </div>
          </DraggableSidebar>
        )}

        {/* Main Editor Area */}
        <div className="flex-1 relative bg-gray-100 overflow-hidden">
          {/* Main Stage */}
          <div className="flex-1 flex items-center justify-center overflow-auto bg-gray-100 p-4">
            {/* Desktop Sidebar Toggle - Show when sidebar is hidden */}
            {!showSidebar && (
              <div className="hidden md:block absolute top-4 left-4 z-30">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowSidebar(true)}
                  className="bg-white shadow-lg"
                  title="Show Products"
                >
                  <Menu className="w-4 h-4 mr-2" />
                  Show Products
                </Button>
              </div>
            )}

            {selectedProduct ? (
              <div className="relative w-full h-full bg-gray-100 min-h-[600px]">
                <EditorStage
                  ref={editorRef}
                  widthMm={canvasDimensions.width}
                  heightMm={canvasDimensions.height}
                  onStateChange={handleStateChange}
                  onElementSelect={handleElementSelect}
                />

                {/* Fallback text input when text tool is selected */}
                {selectedTool === "text" && (
                  <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-lg p-3 border z-20">
                    <div className="flex items-center space-x-2">
                      <Type className="w-4 h-4 text-gray-600" />
                      <input
                        type="text"
                        placeholder="Type your text here..."
                        className="px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 min-w-[200px]"
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') {
                            const text = e.currentTarget.value.trim();
                            if (text) {
                              if (editorRef.current?.addText) {
                                editorRef.current.addText(text);
                                toast({
                                  title: "Text Added",
                                  description: `"${text}" added to canvas`,
                                });
                              } else {
                                toast({
                                  title: "Error",
                                  description: "Editor not ready yet",
                                  variant: "destructive",
                                });
                              }
                              e.currentTarget.value = '';
                            }
                          }
                        }}
                      />
                      <Button
                        size="sm"
                        onClick={() => {
                          const input = document.querySelector('input[placeholder="Type your text here..."]') as HTMLInputElement;
                          if (input && input.value.trim()) {
                            const text = input.value.trim();
                            if (editorRef.current?.addText) {
                              editorRef.current.addText(text);
                              toast({
                                title: "Text Added",
                                description: `"${text}" added to canvas`,
                              });
                            } else {
                              toast({
                                title: "Error",
                                description: "Editor not ready yet",
                                variant: "destructive",
                              });
                            }
                            input.value = '';
                          }
                        }}
                        className="px-3 py-1 text-xs"
                      >
                        Add
                      </Button>
                    </div>
                    <p className="text-xs text-gray-500 mt-1">Press Enter or click Add to place text on canvas</p>
                  </div>
                )}

                {/* Canvas Info Overlay */}
                <div className="absolute bottom-2 left-2 md:bottom-2 md:left-2 bg-white/90 backdrop-blur-sm rounded-lg p-2 md:p-1 shadow-sm z-10">
                  <div className="text-xs md:text-xs text-gray-600 space-y-0.5">
                    <div className="flex items-center space-x-2 md:space-x-1">
                      <span className="hidden md:inline">Size:</span>
                      <span className="md:hidden">📐</span>
                      <span className="font-medium">
                        {selectedProduct.dimensions ? `${selectedProduct.dimensions.width}×${selectedProduct.dimensions.height}mm` : 'N/A'}
                      </span>
                    </div>
                    <div className="flex items-center space-x-2 md:space-x-1">
                      <span className="hidden md:inline">Elements:</span>
                      <span className="md:hidden">🎨</span>
                      <span className="font-medium">{selectedElements.length}</span>
                    </div>
                    <div className="flex items-center space-x-2 md:space-x-1">
                      <span className="hidden md:inline">Zoom:</span>
                      <span className="md:hidden">🔍</span>
                      <span className="font-medium">{Math.round(zoom * 100)}%</span>
                    </div>
                  </div>
                </div>

                {selectedElements.length > 0 && (
                  <div className="absolute top-12 md:top-2 right-2 bg-white/90 backdrop-blur-sm rounded-lg p-2 md:p-1 shadow-sm z-10">
                    <div className="flex items-center space-x-2 md:space-x-1">
                      <CheckCircle className="w-4 h-4 md:w-3 md:h-3 text-green-600" />
                      <span className="text-sm md:text-xs font-medium text-gray-700">
                        {selectedElements.length} selected
                      </span>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="flex items-center justify-center h-full">
                <div className="text-center max-w-sm mx-auto p-4 md:p-6">
                  <div className="w-16 h-16 md:w-12 md:h-12 mx-auto bg-blue-100 rounded-full flex items-center justify-center mb-4 md:mb-3">
                    <Plus className="w-8 h-8 md:w-6 md:h-6 text-blue-600" />
                  </div>
                  <h3 className="text-lg md:text-sm font-medium text-gray-900 mb-2 md:mb-1">
                    Choose Product
                  </h3>
                  <p className="text-sm md:text-xs text-gray-600 mb-4 md:mb-3">
                    Select a product from the sidebar to start designing
                  </p>
                  <Button
                    onClick={() => setShowSidebar(true)}
                    className="bg-primary text-white hover:bg-primary-600 h-10 md:h-8 px-4 md:px-3 text-sm md:text-xs"
                  >
                    <Menu className="w-4 h-4 mr-2 md:hidden" />
                    Browse Products
                  </Button>
                </div>
              </div>
            )}
          </div>


        </div>
      </div>

      {/* Draggable Properties Panel */}
      {selectedProduct && showPropertiesPanel && (
        <PropertiesPanel
          selectedElementData={selectedElements[0]}
          key={`desktop-properties-${selectedElements[0]?.id || 'none'}-${Date.now()}`}
          selectedColors={selectedColors}
          canvasDimensions={canvasDimensions}
          setCanvasDimensions={setCanvasDimensions}
          editorRef={editorRef}
          onDeleteSelected={handleDeleteSelected}
          onAddToCart={handleAddToCart}
          onDownloadPreview={handleDownloadPreview}
          generateColorPaletteMutation={generateColorPaletteMutation}
          validateForPrint={handleValidateForPrint}
          exportForPrint={handleExportForPrint}
          quantity={cartQuantity}
          setQuantity={setCartQuantity}
          designName={designName}
          setDesignName={setDesignName}
          onPropertyChange={() => {}}
          onDelete={() => {}}
          onMoveUp={() => {}}
          onMoveDown={() => {}}
        />
      )}

      {/* Template Gallery Modal */}
      {showTemplateGallery && (
        <TemplateGallery
          onSelectTemplate={handleTemplateSelect}
          onClose={() => setShowTemplateGallery(false)}
          currentProductId={selectedProduct?.id}
        />
      )}

      {/* AI Tools Panel Modal */}
      {showAIPanel && (
        <AIEnhancedToolsPanel
          isOpen={showAIPanel}
          onClose={() => setShowAIPanel(false)}
          editorRef={editorRef}
          selectedElementData={selectedElements[0]}
          generateImageMutation={generateDesignMutation}
          removeBackgroundMutation={generateColorPaletteMutation}
          generateTextMutation={generateDesignMutation}
          generateColorPaletteMutation={generateColorPaletteMutation}
        />
      )}
    </div>
  );
}
